## 02.Bower API

Bower 의 API 에 대해서 알아봅니다.

자주 사용하지는 않지만 참고적으로 알아두면 좋습니다.


### cache

bower 캐시 관리하기

```sh
$ bower cache <command> [<args>]
```

- cache clean

캐시된 패키지를 삭제합니다.

```sh
$ bower cache clean
$ bower cache clean <name> [<name> ...]
$ bower cache clean <name>#<version> [<name>#<version> ..]
```

- cache list

캐시된 패키지 리스트를 열거합니다.

```sh
$ bower cache list
$ bower cache list <name> [<name> ...]
```



### help

bower에 대한 도움말 정보를 표시합니다.

```sh
$ bower help <command>
```


### home

기본 브라우저에서 패키지 홈페이지를 엽니다.

`<package>` 가 전달되지 못한 경우, 로컬 패키지의 홈페이지를 엽니다.

```sh
$ bower home
$ bower home <package>
$ bower home <package>#<version>
```


### info
패키지의 전체 정보 또는 특정 버전의 전체 정보를 표시합니다.

```sh
$ bower info <package>
$ bower info <package> [<property>]
$ bower info <package>#<version> [<property>]
```



### init
`bower.json` 파일을 생성합니다.

```sh
$ bower init
```


### install
프로젝트 의존성 파일 또는 특정한 엔드포인트 세트를 설치합니다.

```sh
$ bower install [<options>]
$ bower install <endpoint> [<endpoint> ..] [<options>]
```

엔드포인트는 여러 형태를 가질 수 있습니다 :

* `<package>`
* `<package>#<version>`
* `<name>=<package>#<version>`

설치장소:

* `<package>` 는 패키지 URL, 물리적인 위치 혹은 레지스트리 입니다.
* `<version>` 은 유효한 범위, 커밋, 브렌치 등등 입니다.
* `<name>` 은 지역적으로 설치되어야 하는 이름입니다.


__`install` 옵션__

* `-F`, `--force-latest`: 충돌시 가장 최신 버전을 강제로 설치합니다.
* `-p`, `--production`: 프로젝트 devDependencies를 설치하지 않습니다.
* `-S`, `--save`: 설치된 패키지들을 프로젝트의 bower.json의 종속관계로 저장합니다.
* `-D`, `--save-dev`: 설치된 프로젝트의 bower.json의 devDependencies에 저장합니다.
* -E, --save-exact: semver버전보다는 정확한 버전으로 설치된 패키지를 구성합니다.



### link

```sh
$ bower link
$ bower link <name> [<local name>]
```

link 기능은 개발자가 쉽게 패키지를 테스트 할 수 있게 합니다.링크는 두 단계의 프로세스 입니다.

프로젝트 폴더 안의  'bower link'를 사용하면 글로벌 링크가 생성됩니다.그런 다음, 다른 패키지에서 bower link <name>를 사용하면, 컴포넌트 폴더 안에 이전에 생성된 링크를 가리키는 폴더를 생성합니다.

변경 사항이 즉시 반영되기 때문에 쉽게 패키지를 테스트 할 수 있습니다.링크가 더 이상 필요하지 않을 경우, 단순히 그것을 제거하거나 bower uninstall <name>을 사용하면 됩니다.


### list
로컬패키지 및 가능한 업데이트를 나열합니다.

```sh
$ bower list [<options>]
```


### list options

-p, --paths: 간단한 JSON 소스 매핑을 생성합니다.
-r, --relative: 디렉토리 설정값에 상대적인 경로로 만듭니다. bower_components가 기본으로 설정되어 있습니다.


### lookup
이름으로 패키지 URL을 검색합니다

```sh
$ bower lookup <name>
```



### login
GitHub에 저장된 자격 증명을 사용하여 인증합니다.패키지의 등록을 취소하는 데 필요합니다.

```sh
$ bower login
```

### login options

* `--t`, `--token`: 사용자 이름과 암호를 입력창에 띄우기전에 기존에 있던 GitHub의 인증 토큰을 전달해 줍니다.


### prune
로컬에 있는 필요없는 패키지를 제거합니다

```sh
$ bower prune
```


### register
패키지를 등록합니다.

```sh
$ bower register <name> <url>
```

`bower` 패키지를 등록할때 `register` 를 이용해서 등록합니다.
`name` 패키지의 이름이고 `url` 은 패키지의 git 저장소의 주소입니다.




### search
모든 패키지 또는 특정 패키지를 찾습니다.

```sh
$ bower search
$ bower search <name>
```


### update
bower.json의 버전에 따라서 설치된 패키지의 업데이트를 설치합니다.

```sh
$ bower update <name> [<name> ..] [<options>]
```

### update options

* `-F`, `--force-latest`: 충돌이 있을 경우, 최신 버전으로 업데이트 합니다.
* `-p`, `--production`: 프로젝트 devDependencies를 설치하지 않습니다.


### uninstall
bower_components를 설치한 디렉토리에서 로컬 패키지를 제거합니다.

```sh
$ bower uninstall <name> [<name> ..] [<options>]
```

### uninstall options

* `-S`, `--save`: 프로젝트의 bower.json 종속파일에서 패키지를 제거합니다.
* `-D`, `--save-dev`: 프로젝트의 bower.json의 devDependencies에서 패키지를 제거합니다.



### unregister
패키지의 등록을 해제합니다.

```sh
$ bower unregister <package>
```

### version
버전에서 업데이트 하기 위해서 패키지 디렉토리에서 실행한다. bower.json 파일에 새로운 데이터를 기록합니다.

```sh
$ bower version [<newversion> | major | minor | patch]
```

`newversion` 인자는 유효한 s​​emver 문자열, 또는 semver.inc( "build", "patch", "minor", "major")에  유효한 두 번째 인수이어야 합니다.
두 번째 경우에는, 특정 필드에서는 기존의 버전이 1씩 증가합니다.

git repo에서 실행하는 경우, 버전의 커밋과 태그를 생성하며, repo가 깨끗하지 않으면 생성되지 않습니다.



### version options

`-m`, `--message`: git 커밋을 커스터마이징하고 메시지를 태그합니다.
버전 커밋을 생성할때, -message(단축키: -m) 설정 옵션과 함께 제공되는 경우, bower는 설정옵션을 메시지를 커밋할 때 사용합니다.메시지 설정에 %s가 포함되어있는 경우, 그 결과 버전 번호로 대체됩니다.

예를 들면:

```sh
$ bower version patch -m "Upgrade to %s for reasons"
```

## Options

* [force](#force)
* [json](#json)
* [log-level](#log-level)
* [offline](#offline)
* [quiet](#quiet)
* [silent](#silent)
* [verbose](#verbose)
* [allow-root](#allow-root)


### force

```sh
-f, --force
```

다양한 명령들을 강제적으로 만듭니다.



### json

```sh
-j, --json
```

`bower.json` 사용할수 있는 내용을 출력합니다.


### log-level

```sh
-l, --log-level
```

로그 수준을 보여줍니다.
가능한값: error, conflict, warn, action, info, debug



### offline

```sh
-o, --offline
```

네트워크 연결을 사용하지 않습니다.



### quiet

```sh
-q, --quiet
```

중요한 정보만 출력합니다.



### silent

```sh
-s, --silent
```

오류 외에 아무것도 출력하지 않습니다.



### verbose

```sh
-V, --verbose
```

출력을 더 자세하게 만듭니다.



### allow-root

```sh
--allow-root
```

루트에서 명령어를 실행 할 수 있습니다.
Bower는 슈퍼 유저 권한을 실행할 필요가 없는 사용자 명령입니다.

그러나, 여전히 sudo 명령을 실행하고 싶은 경우, --allow-root 옵션을 사용합니다.











-------




Bower는 가능한 소스 매핑을 만듭니다.
빌드툴을 사용하면 소스 매핑을 만들 수 있고 Bower 패키지를 소비하게 됩니다.

`bower list --paths` 또는 `bower list --paths --json`를 사용하는 경우, 설치한 플러그인의 이름과 경로를 보여줍니다.

```sh
$ bower list --paths
# or
$ bower list --paths --json
```

```sh
{
  "backbone": "bower_components/backbone/backbone.js",
  "jquery": "bower_components/jquery/dist/jquery.js",
  "underscore": "bower_components/underscore/underscore.js"
}
```

모든 명령어는 --json 옵션을 지원하며, Bower가 JSON을 출력하도록 합니다.




<br />











## 프로그래밍 API

Bower는 강력한 프로그래밍 API를 제공합니다. 모든 명령은 bower.commands 객체를 통해 접근할 수 있습니다.

```javascript
var bower = require('bower');

bower.commands
.install(['jquery'], { save: true }, { /* custom config */ })
.on('end', function (installed) {
    console.log(installed);
});

bower.commands
.search('jquery', {})
.on('end', function (results) {
    console.log(results);
});
```

명령어는 네 가지 유형의 이벤트를 발생합니다: log, prompt, end, error.

* `log`는 명령의 상태 / 진행을 보고하기 위해 발생됩니다.
* `prompt` 사용자가 프롬프트창에 입력할 때마다 발생됩니다.
* `error`는 뭔가 잘못된 일이 있을 경우에만 발생됩니다.
* `end`는 명령이 성공적으로 종료 될 때 발생됩니다.

이 작업을 수행수행하기 위한 더 좋은 생각은 우리의 [bin file](https://github.com/bower/bower/blob/master/bin/bower)을 확인하길 바랍니다.

![bin file](../images/demun-151.jpg)
`demun-151.jpg`

bower를 계획에 따라서 사용하는 경우, 프롬프트는 기본적으로 비활성화 되어 있습니다.
설정파일에서 `interactive: true`라는 명령어를 부르면 활성화 시킬수 있습니다. prompt 이벤트를 받고 제어할 수 있어야 활성화 할 수 있습니다.
가장 쉬운 방법은 `inquirer NPM` 모듈을 사용하는 것입니다.

`inquirer NPM 모듈` [https://www.npmjs.com/package/inquirer](https://www.npmjs.com/package/inquirer)

![inquirer](../images/demun-153.jpg)
`demun-153.jpg`

```javascript
var inquirer =  require('inquirer');

bower.commands
.install(['jquery'], { save: true }, { interactive: true })
// ..
.on('prompt', function (prompts, callback) {
    inquirer.prompt(prompts, callback);
});
```



### 비 대화식 모드

Bower는 기본적으로 대화형 모드에서 작동합니다.
그것을 해제하는 몇 가지 방법이 있습니다.

* 환경설정에서 `CI=true`를 입력합니다.
* `bower` 명령어로 `--config.interactive=false`를 입력합니다.
* `bower install | cat`와 같은 파이프(세로줄)를 `bower`에 추가합니다.
* `bower install > logs.txt`와 같이 출력을 파일로 리디렉션 합니다.
* `Programmatic API`를 통해서 bower를 실행합니다.


대화형 모드가 비활성화 되었을 때:

* `bower init`이 작동하지 않습니다.
* `bower register` 및 `bower unregister`가 확인을 우회합니다.
* `--token` 매개 변수가 제공되지 않는 이상 `bower login`이 실패합니다.
* `bower install`은 선택을 묻지 않습니다.
* `bower uninstall`은 종속파일이 제거 될 경우, 확인을 요구하지 않는다
* 웹 로그 분석은 기본적으로 비활성화되어 있습니다 (`--config.analytics=false`을 전달하는 것과 같음)



### 로컬 캐시를 사용하기

패키지가 이전에 설치된 경우, `bower`는 인터넷 연결 없이 로컬 캐시에서 패키지 설치를 지원합니다.

```sh
$ bower install <package> --offline
```

`bower cache list`로 캐시의 내용을 나열 할 수 있습니다.

```sh
$ bower cache list
```

`bower cache clean` 으로 캐시를 삭제할 수 있습니다.

```sh
$ bower cache clean
```
